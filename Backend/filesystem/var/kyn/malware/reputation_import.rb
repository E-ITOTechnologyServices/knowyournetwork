#!/usr/bin/ruby
# reputation_import.rb 20170110
# Markus Jahnke
# ingest reputation lists from multiple sources


# Copyright (C) 2017 e-ito Technology Services GmbH
# e-mail: info@e-ito.de

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


require 'elasticsearch'
require 'getoptlong'
require 'open-uri'
require 'ipaddr'
require 'time'
# require 'maxminddb'

# check whether IPv4 address is public
def is_public(ip)

  private_ip_addresses = ["0.0.0.0/8",
                          "10.0.0.0/8",
                          "127.0.0.0/8",
                          "169.254.0.0/16",
                          "172.16.0.0/12",
                          "192.0.0.0/24",
                          "192.0.2.0/24",
                          "192.88.99.0/24",
                          "192.168.0.0/16",
                          "198.18.0.0/15",
                          "198.51.100.0/24",
                          "203.0.113.0/24",
                          "223.255.255.0/24",
                          "224.0.0.0/4",
                          "240.0.0.0/4",
                          "255.255.255.255"]

  private_ip_addresses.each do |private_ip| 
    if IPAddr.new(private_ip).include? ip
      return false
    end
  end
  return true
end

# disable proxy 
ENV['http_proxy']=nil

# defaults
eshost = "http://elasticsearch:9200"
elastic_bulk = { body: [] }
file = '/var/kyn/malware/reputation_urls.txt'
# geodb = MaxMindDB.new('/usr/local/share/GeoIP/GeoLite2-City.mmdb')

# initial
counter = 0
reputation = {}

# cli arguments
opts = GetoptLong.new(
  ["--eshost", "-e", GetoptLong::REQUIRED_ARGUMENT],
  ["--help", "-?", GetoptLong::NO_ARGUMENT],
  ["--files", "-f", GetoptLong::REQUIRED_ARGUMENT]  
)

opts.each do |opt, arg|
  case opt
  when "--help"
    puts <<-EOF
    
IP reputation importer | Syntax: 

  --eshost|-e     elasticsearch host, default: #{eshost}
  --help|-?       display this page
  --file|-f       file to read from, default: #{file}  

EOF
    exit 0
  when "--eshost"
    eshost = arg
  when "--ingest"
    file = arg
  end
end

# elasticsearch client object
client = Elasticsearch::Client.new url: eshost #, log: true

# read import list
reputation_urls = File.open(file, 'r')
puts "loaded URLs from #{file}"

# work on url
reputation_urls.each_line do |url|

  url.strip!
  begin
    reputation_data  = open(url) 
  rescue
    puts "skipping bad URL \"#{url}\""
    next
  end
  puts "ingesting from #{url}"
  reputation_data.each_line do |line|
    # just work on lines starting with an IPv4 address
    if line =~ /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)/ then
      ip = line[/^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))/,1]
      # ignore private IP addreses
      if is_public(ip) then
        reputation['@timestamp'] = Time.now.iso8601
        reputation['host'] = ip
        reputation['description'] = url
        # georet = geodb.lookup(ip)
        # reputation["geoip"] = {}
        # reputation["geoip"]["country"] = georet.country.name('en') unless georet.country.name('en') == nil
        # reputation["geoip"]["city"] = georet.city.name('en') unless georet.city.name('en') == nil
        # reputation["geoip"]["location"] = {}
        # reputation["geoip"]["location"]["lat"] = georet.location.latitude unless georet.location.latitude == nil
        # reputation["geoip"]["location"]["lon"] = georet.location.longitude unless georet.location.longitude == nil

        elastic_bulk[:body].push({ index: { _index: 'kyn-malware', _type: 'malware', _id: reputation['host'] } })
        elastic_bulk[:body].push(reputation.clone)
        counter += 1
        if counter == 5000 then
          client.bulk elastic_bulk
          elastic_bulk = { body: [] }
          counter = 0
        end
      end
    end
  end
end
reputation_urls.close
# sending the bulk to elasticsearch (catch all ...)
if elastic_bulk != { body: [] }
  client.bulk elastic_bulk
end

puts "done"
